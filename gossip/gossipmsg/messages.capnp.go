// Code generated by capnpc-go. DO NOT EDIT.

package gossipmsg

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	strconv "strconv"
)

type Message capnp.Struct
type Message_Which uint16

const (
	Message_Which_data   Message_Which = 0
	Message_Which_noData Message_Which = 1
)

func (w Message_Which) String() string {
	const s = "datanoData"
	switch w {
	case Message_Which_data:
		return s[0:4]
	case Message_Which_noData:
		return s[4:10]

	}
	return "Message_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Message_TypeID is the unique identifier for the type Message.
const Message_TypeID = 0xa1200f31f3714f35

func NewMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4})
	return Message(st), err
}

func NewRootMessage(s *capnp.Segment) (Message, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4})
	return Message(st), err
}

func ReadRootMessage(msg *capnp.Message) (Message, error) {
	root, err := msg.Root()
	return Message(root.Struct()), err
}

func (s Message) String() string {
	str, _ := text.Marshal(0xa1200f31f3714f35, capnp.Struct(s))
	return str
}

func (s Message) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Message) DecodeFromPtr(p capnp.Ptr) Message {
	return Message(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Message) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Message) Which() Message_Which {
	return Message_Which(capnp.Struct(s).Uint16(0))
}
func (s Message) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Message) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Message) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Message) Id() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Message) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Message) SetId(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Message) Signer() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Message) HasSigner() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Message) SetSigner(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Message) Signature() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Message) HasSignature() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Message) SetSignature(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Message) Data() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != data")
	}
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Message) HasData() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(3)
}

func (s Message) SetData(v []byte) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetData(3, v)
}

func (s Message) SetNoData() {
	capnp.Struct(s).SetUint16(0, 1)

}

// Message_List is a list of Message.
type Message_List = capnp.StructList[Message]

// NewMessage creates a new list of Message.
func NewMessage_List(s *capnp.Segment, sz int32) (Message_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 4}, sz)
	return capnp.StructList[Message](l), err
}

// Message_Future is a wrapper for a Message promised by a client call.
type Message_Future struct{ *capnp.Future }

func (f Message_Future) Struct() (Message, error) {
	p, err := f.Future.Ptr()
	return Message(p.Struct()), err
}

const schema_fbd8d724be65e33e = "x\xda<\xcc\xb1J3A\x14\xc5\xf1sf\xe6K\xaa" +
	"%\xdf\xc0T\x82\x98\xc2J\xd0\xb0\x85M\x0a\x15\xd1R" +
	"\xf4\xfa\x06\x83Y\x96-\xb2Y3+Xh!DH" +
	"\xa1\x10\xc1\xc2\xd6\x17\xd1\xca\x07\xb0\x10\xed}\x04K\xc1" +
	"\x91Ubu\xf9\xfd\xb9\x9c\xff\xb3-\x93&\x8f\x84\x12" +
	"\xf7\xaf\x15\xd7\xf7\x8f?\xd2N\xf7\x1e\xd2%\xe3\xc6{" +
	"\xf6\xb0\xfc\xfa\xf6\x89]\xd3V@\xfa\xb4M\xfb\xd2\x06" +
	"\xd2\xe7%b5\xe6\xa3\x10\x8a\xaa\x97\x9b\x9f;\x0cy" +
	"o\x98\x85\xe0\xf3,\xac\x1d\xf9\xaa\xac\xfa{\xbf\xc4\x01" +
	")N\x1b\xc0\x10\xb0\xe7\x0b\x80\x9cj\xcaD\xd1\x92\x8e" +
	"M\xbc\xe8\x03r\xa6)SE\xab\x94\xa3\x02\xec\xe5!" +
	" \x13M\x99).\xea\x18\xb5\xa3\x06\xec\xf5\x0a S" +
	"M\xb9UL\xccWt4\x80\xbdi\x16\xae4\xe5N" +
	"Q\x17\x03&PL\xc0\xcdP\xe4e6\x9e36\xf4" +
	"\xf5\xc9\x18\xcc\xe6\xad3\xf0\xb5\xff\xfb/G;\xbe\xf6" +
	"h}\x07\x00\x00\xff\xffqr@4"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_fbd8d724be65e33e,
		Nodes: []uint64{
			0xa1200f31f3714f35,
		},
		Compressed: true,
	})
}
